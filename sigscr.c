/*
 *==============================================================================
 *345678901234567890123456789012345678901234567890123456789012345678901234567890
 *
 *   File:  sigscr.c
 *   Copyright 2022  David J. Webb
 *
 *   File contains subroutines for processing the signal script trees
 *   generated by the bison program.
 *
 *   Released under licence GPL-3.0-or-later
 *
 *   ZR is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   ZR is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with ZR.  If not, see <https://www.gnu.org/licenses/>.
 *
 *==============================================================================
 */
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include "sigscr.h"
#include "y.tab.h"

static char *token[] = {
    "PROGRAM",
    "FUNCTION",
    "VARIABLE",
    "NAME",
    "IVALUE",
    "FVALUE",
    "EXTERN",
    "FLOAT",
    "SCRIPT",
    "IF",
    "ELSE",
    "FOR",
    "WHILE",
    "DO",
    "BREAK",
    "CONTINUE",
    "RETURN",
    "PRINT",
    "UMINUS",
    "SCRIPT_LIST",
    "DEF_LIST",
    "STMT_LIST",
    "DEF_EFUN",
    "DEF_EVAR",
    "DEF_VAR",
    "EXIT",
    "ASSIGN", "IAS",
    "PE", "ME", "XE", "DE",
    "IASD", "IMD", "IFX",
    "BB",
    "NO_OP",
    "NEG",
    "COMMA", "EXPR_LIST",
    "AND", "OR", "EOR", "NOT", "INT",
    "GT" "LT" "GE", "LE", "EQ", "NE",
    "IGT", "ILT", "IGE", "ILE", "IEQ", "INE",
    "POW"
} ;

extern int yydebug ;
FILE       *yyin, *yyout ;
int        yyparse(nodeType **sTree) ;
void       yyset_in(FILE *sfile)     ;

int print_sigscr_node(nodeType *p)   ;

nodeType   *sTree = NULL;
char       *file_in = "sigscr_zigzag.dat" ;
int        itree_depth = 0 ;

/*
 *  Routine to read signal script file and initialise the tree pointer sTree.
 */
int read_sigscr_file(){

int  ip = 1 ;
int  iret ;

      yydebug = 0 ;

      yyin = fopen(file_in, "r");
      if(ip)printf("  File opened : %s\n",file_in) ;
      yyset_in(yyin) ;
      iret = yyparse(&sTree);
      if(ip)printf("  Close file \n") ;
      fclose(yyin);
      if(iret){
        printf("  Unable to parse signal script file\n");
        printf("  Error return value = %i\n",iret);
        exit(0) ;
      }
      if(!ip) return 0 ;
      printf("  sTree = %p\n",(void *)sTree) ;
      printf("  sTree->type = %i\n",sTree->type) ;
      printf("  sTree->opr.oper = %i\n",sTree->opr.oper) ;
      printf("  sTree->opr.nops = %i\n",sTree->opr.nops) ;

      printf("\n PRINT TREE\n") ;
      print_sigscr_node(sTree) ;

      return 0 ;
}

int print_sigscr_node(nodeType *p){

int i, n, nops, oper, type ;

      if(p == NULL) return 0 ;
      type = p->type ;
#if 0
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
      printf("  ENTER  print_sigscr_node\n") ;
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
      printf("  psn :: p       = %p\n",(void *)p) ;
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
      printf("  psn :: p->type = %i\n",type)      ;
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
#endif
      if(type == typeStr){
        for(i=0;i<itree_depth;i++)printf("  ") ;
        printf("  psn : str :: name = %s\n",p->str.name) ;
      }else if( type == typeOpr){
        oper = p->opr.oper ;
        nops = p->opr.nops ;
        for(i=0;i<itree_depth;i++)printf("  ") ;
        if(oper >= SC_PROGRAM && oper <= SC_POW){
          printf("  psn : opr :: %i %i %s\n",nops,oper,token[oper-SC_PROGRAM]);
        }else{
          printf("  psn : opr :: %i %i %s\n",nops,oper,"INDEX OUT OF RANGE");
        }
        itree_depth++ ;
        for(n=0;n<nops;n++){
#if 0
          for(i=0;i<itree_depth;i++)printf("  ") ;
          printf("  psn : opr :: index = %i\n",n) ;
#endif
          print_sigscr_node(p->opr.op[n]);
        }
        itree_depth-- ;
      }else{
        printf(" ERROR in routine print_sigscr_node\n");
        printf(" psn ::     type = %i\n",type) ;
        exit(0) ;
      }
      return 0 ;
}

int print_sigscr_tree(nodeType *p){

int ip = 0 ;

      if(!ip)return 0 ;
      printf("  ENTER  print_sigscr_tree\n") ;
      printf("  pst ::       p   = %p\n",(void *)p) ;
      itree_depth = 0 ;
      print_sigscr_node(p) ;
      return 0 ;
}

